# Phase 5.1: Core Models

## Overview

Create the foundational models for representing menu bar items and their identifiers.

## Files to Create

### 1. `Drawer/Models/MenuBarItemInfo.swift`

A lightweight, hashable identifier for menu bar items that persists across captures.

```swift
//
//  MenuBarItemInfo.swift
//  Drawer
//
//  Copyright © 2026 Drawer. MIT License.
//

import Foundation

/// A lightweight identifier for a menu bar item.
/// Used to track items across window list refreshes.
struct MenuBarItemInfo: Hashable, Codable {
    /// The namespace (typically bundle identifier) of the owning app.
    let namespace: String
    
    /// The title of the menu bar item window.
    let title: String
    
    // MARK: - Known Control Items
    
    /// Identifier for Drawer's hidden section control item (separator).
    static let hiddenControlItem = MenuBarItemInfo(
        namespace: Bundle.main.bundleIdentifier ?? "com.drawer",
        title: "HiddenControlItem"
    )
    
    /// Identifier for Drawer's always-hidden section control item.
    static let alwaysHiddenControlItem = MenuBarItemInfo(
        namespace: Bundle.main.bundleIdentifier ?? "com.drawer",
        title: "AlwaysHiddenControlItem"
    )
    
    // MARK: - Immovable Items
    
    /// System items that macOS does not allow to be repositioned.
    static let immovableItems: Set<MenuBarItemInfo> = [
        // Control Center items
        MenuBarItemInfo(namespace: "com.apple.controlcenter", title: "BentoBox"),
        MenuBarItemInfo(namespace: "com.apple.controlcenter", title: "Clock"),
        // Siri
        MenuBarItemInfo(namespace: "com.apple.Siri", title: "Siri"),
        // Spotlight
        MenuBarItemInfo(namespace: "com.apple.Spotlight", title: "Spotlight"),
    ]
    
    /// Returns true if this item is a system item that cannot be moved.
    var isImmovable: Bool {
        Self.immovableItems.contains(self)
    }
}
```

### 2. `Drawer/Models/MenuBarItem.swift`

A full representation of a menu bar item with window information.

```swift
//
//  MenuBarItem.swift
//  Drawer
//
//  Copyright © 2026 Drawer. MIT License.
//

import AppKit
import Foundation

/// Represents a menu bar item with its window and positioning information.
struct MenuBarItem: Equatable, Hashable {
    /// The window identifier for this menu bar item.
    let windowID: CGWindowID
    
    /// The frame of the item's window in screen coordinates.
    let frame: CGRect
    
    /// The process identifier of the owning application.
    let ownerPID: pid_t
    
    /// The name of the owning application.
    let ownerName: String?
    
    /// The title of the menu bar item window.
    let title: String?
    
    /// The bundle identifier of the owning application.
    let bundleIdentifier: String?
    
    /// The unique identifier for this item.
    var info: MenuBarItemInfo {
        MenuBarItemInfo(
            namespace: bundleIdentifier ?? ownerName ?? "unknown",
            title: title ?? ""
        )
    }
    
    /// Returns true if this item can be repositioned.
    var isMovable: Bool {
        !info.isImmovable
    }
    
    /// A display name suitable for showing to users.
    var displayName: String {
        if let title, !title.isEmpty {
            return title
        }
        if let ownerName {
            return ownerName
        }
        return "Unknown"
    }
    
    // MARK: - Initialization
    
    /// Creates a MenuBarItem from window information dictionary.
    /// Returns nil if the dictionary doesn't represent a valid menu bar item.
    init?(windowInfo: [String: Any]) {
        guard
            let windowID = windowInfo[kCGWindowNumber as String] as? CGWindowID,
            let boundsDict = windowInfo[kCGWindowBounds as String] as? [String: CGFloat],
            let x = boundsDict["X"],
            let y = boundsDict["Y"],
            let width = boundsDict["Width"],
            let height = boundsDict["Height"],
            let ownerPID = windowInfo[kCGWindowOwnerPID as String] as? pid_t
        else {
            return nil
        }
        
        self.windowID = windowID
        self.frame = CGRect(x: x, y: y, width: width, height: height)
        self.ownerPID = ownerPID
        self.ownerName = windowInfo[kCGWindowOwnerName as String] as? String
        self.title = windowInfo[kCGWindowName as String] as? String
        
        // Look up bundle identifier from running applications
        if let app = NSRunningApplication(processIdentifier: ownerPID) {
            self.bundleIdentifier = app.bundleIdentifier
        } else {
            self.bundleIdentifier = nil
        }
    }
    
    /// Creates a MenuBarItem from a window ID by fetching current window info.
    init?(windowID: CGWindowID) {
        guard let frame = Bridging.getWindowFrame(for: windowID) else {
            return nil
        }
        
        // Get window info from CGWindowListCopyWindowInfo
        let windowList = CGWindowListCopyWindowInfo([.optionIncludingWindow], windowID) as? [[String: Any]]
        guard let windowInfo = windowList?.first else {
            return nil
        }
        
        self.windowID = windowID
        self.frame = frame
        self.ownerPID = windowInfo[kCGWindowOwnerPID as String] as? pid_t ?? 0
        self.ownerName = windowInfo[kCGWindowOwnerName as String] as? String
        self.title = windowInfo[kCGWindowName as String] as? String
        
        if let app = NSRunningApplication(processIdentifier: self.ownerPID) {
            self.bundleIdentifier = app.bundleIdentifier
        } else {
            self.bundleIdentifier = nil
        }
    }
    
    // MARK: - Equatable/Hashable
    
    static func == (lhs: MenuBarItem, rhs: MenuBarItem) -> Bool {
        lhs.windowID == rhs.windowID
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(windowID)
    }
}

// MARK: - Fetching Menu Bar Items

extension MenuBarItem {
    /// Returns all current menu bar items, sorted by X position (left to right).
    ///
    /// - Parameters:
    ///   - onScreenOnly: If true, only returns items currently visible on screen.
    ///   - activeSpaceOnly: If true, only returns items on the active space.
    /// - Returns: Array of MenuBarItem sorted by X position.
    static func getMenuBarItems(
        onScreenOnly: Bool = false,
        activeSpaceOnly: Bool = true
    ) -> [MenuBarItem] {
        var options: Bridging.WindowListOption = [.menuBarItems]
        if onScreenOnly {
            options.insert(.onScreen)
        }
        if activeSpaceOnly {
            options.insert(.activeSpace)
        }
        
        let windowIDs = Bridging.getWindowList(option: options)
        
        return windowIDs
            .compactMap { MenuBarItem(windowID: $0) }
            .sorted { $0.frame.origin.x < $1.frame.origin.x }
    }
    
    /// Finds a menu bar item matching the given info.
    static func find(matching info: MenuBarItemInfo) -> MenuBarItem? {
        getMenuBarItems().first { $0.info == info }
    }
}
```

## Acceptance Criteria

- [ ] `MenuBarItemInfo` is `Hashable` and `Codable`
- [ ] `MenuBarItemInfo.immovableItems` contains Control Center, Clock, Siri, Spotlight
- [ ] `MenuBarItem` can be created from window ID
- [ ] `MenuBarItem.getMenuBarItems()` returns items sorted left-to-right
- [ ] `MenuBarItem.isMovable` returns false for immovable items
- [ ] Typecheck passes: `xcodebuild -scheme Drawer build`

## Testing

```swift
// In DrawerTests/Models/MenuBarItemTests.swift

import XCTest
@testable import Drawer

final class MenuBarItemTests: XCTestCase {
    func testMenuBarItemInfoEquality() {
        let info1 = MenuBarItemInfo(namespace: "com.test", title: "Test")
        let info2 = MenuBarItemInfo(namespace: "com.test", title: "Test")
        XCTAssertEqual(info1, info2)
    }
    
    func testImmovableItems() {
        let controlCenter = MenuBarItemInfo(namespace: "com.apple.controlcenter", title: "BentoBox")
        XCTAssertTrue(controlCenter.isImmovable)
        
        let customApp = MenuBarItemInfo(namespace: "com.example.app", title: "Test")
        XCTAssertFalse(customApp.isImmovable)
    }
    
    func testGetMenuBarItems() async {
        // This test requires the app to be running with menu bar access
        let items = MenuBarItem.getMenuBarItems()
        
        // Should have at least some items (system icons)
        XCTAssertFalse(items.isEmpty)
        
        // Should be sorted by X position
        for i in 0..<(items.count - 1) {
            XCTAssertLessThanOrEqual(items[i].frame.origin.x, items[i + 1].frame.origin.x)
        }
    }
}
```

## Dependencies

- `Bridging.swift` must have `getWindowFrame(for:)` and `getWindowList(option:)` (Phase 5.2)
