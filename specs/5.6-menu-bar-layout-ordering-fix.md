# 5.6 Menu Bar Layout Ordering Fix

## Overview

This specification addresses **Issue 1**: Icons switching positions when clicking the reload button in the Menu Bar Layout settings view.

## Problem Statement

When the user clicks the reload (refresh) button in the Menu Bar Layout settings, the icons visually "switch" positions - they appear in a different order than the actual menu bar. This creates confusion as the settings view no longer reflects reality.

### Root Cause

The `reconcileLayout()` function in `SettingsMenuBarLayoutView.swift` prioritizes the **saved layout order** over the **actual captured order**:

1. Icons are captured from `IconCapturer` with correct X-position ordering
2. The reconciliation uses `savedLayout.first(where:)` to match icons, inheriting the saved order
3. New items get appended at the end regardless of their actual position
4. The result: images get associated with wrong order values, causing visual "switching"

### Expected Behavior

The Menu Bar Layout view should always display icons in their **actual current order** as they appear in the menu bar, regardless of any previously saved layout.

## Technical Design

### Current Flow (Broken)

```
IconCapturer.captureHiddenIcons()
    → Returns [CapturedIcon] sorted by X position
    
reconcileLayout(capturedIcons, savedLayout)
    → Matches each captured icon to savedLayout using first(where:)
    → Uses savedLayout.section and savedLayout.order
    → New icons get order = reconciledItems.count
    
normalizeOrders()
    → Re-sequences orders (0, 1, 2...)
    → Still based on wrong inherited order
```

### New Flow (Fixed)

```
IconCapturer.captureHiddenIcons()
    → Returns [CapturedIcon] with sectionType determined by separator positions
    
reconcileLayout(capturedIcons, savedLayout)
    → Sort captured icons by X position (left to right)
    → Group by sectionType from capture (actual reality)
    → Check savedLayout ONLY for section overrides
    → Assign order based on position within captured section
    
Result: Display matches actual menu bar order
```

## Implementation

### File: `Drawer/UI/Settings/SettingsMenuBarLayoutView.swift`

#### Change 1: Update `reconcileLayout()` function

**Current implementation** (lines 667-724):
```swift
private func reconcileLayout(
    capturedIcons: [CapturedIcon],
    savedLayout: [SettingsLayoutItem]
) -> ReconciliationResult {
    // ... matches captured icons to saved layout using first(where:)
    // ... uses saved section/order
}
```

**New implementation**:
```swift
/// Reconciles captured icons with saved layout.
///
/// Algorithm:
/// 1. Sort captured icons by X position (left to right) - this is the ground truth
/// 2. For each captured icon, determine its section from the capture (based on separator positions)
/// 3. Only check saved layout for section OVERRIDES (user intentionally moved item)
/// 4. Assign order based on captured position within each section
///
/// This ensures the display always matches the actual menu bar order.
///
/// - Parameters:
///   - capturedIcons: Icons captured from the current menu bar state
///   - savedLayout: Previously saved layout items (used only for section overrides)
/// - Returns: Reconciled layout items with image cache and statistics
private func reconcileLayout(
    capturedIcons: [CapturedIcon],
    savedLayout: [SettingsLayoutItem]
) -> ReconciliationResult {
    var reconciledItems: [SettingsLayoutItem] = []
    var newImageCache: [UUID: CGImage] = [:]
    var matchedCount = 0
    var newCount = 0

    // Sort captured icons by X position (left to right) - this is the source of truth
    let sortedIcons = capturedIcons.sorted { $0.originalFrame.minX < $1.originalFrame.minX }

    // Process each section in order
    for sectionType in MenuBarSectionType.allCases {
        // Get icons belonging to this section based on capture (actual reality)
        let sectionIcons = sortedIcons.filter { $0.sectionType == sectionType }

        for (index, capturedIcon) in sectionIcons.enumerated() {
            // Check if saved layout has this item - only for section override detection
            let savedItem = savedLayout.first { saved in
                saved.matches(capturedIcon: capturedIcon)
            }

            // Use captured section as default, but respect user's section override if present
            // A section override means the user intentionally dragged this item to a different section
            let effectiveSection: MenuBarSectionType
            if let savedItem, savedItem.section != capturedIcon.sectionType {
                // User has overridden the section - respect their preference
                effectiveSection = savedItem.section
                matchedCount += 1
            } else {
                // Use the captured section (ground truth)
                effectiveSection = capturedIcon.sectionType
                newCount += 1
            }

            // Create layout item with order based on captured position
            if let item = SettingsLayoutItem.from(
                capturedIcon: capturedIcon,
                section: effectiveSection,
                order: index
            ) {
                reconciledItems.append(item)
                newImageCache[item.id] = capturedIcon.image
            }
        }
    }

    // Preserve spacers from saved layout
    for savedItem in savedLayout where savedItem.isSpacer {
        reconciledItems.append(savedItem)
    }

    // Re-normalize orders within each section to be sequential
    reconciledItems = normalizeOrders(reconciledItems)

    return ReconciliationResult(
        items: reconciledItems,
        imageCache: newImageCache,
        matchedCount: matchedCount,
        newCount: newCount
    )
}
```

### Key Behavioral Changes

| Behavior | Before | After |
|----------|--------|-------|
| Icon display order | Matches saved layout | Matches actual menu bar |
| Section assignment | From saved layout | From capture (with override support) |
| New icons | Appended at end | Placed in correct captured position |
| Refresh result | May differ from reality | Always matches reality |

## Testing

### Manual Test Cases

1. **Reload matches menu bar order**
   - Open Menu Bar Layout settings
   - Note the icon order
   - Click reload button
   - Verify: Icons remain in same order

2. **External reorder is reflected**
   - Open Menu Bar Layout settings
   - Command+Drag an icon in the actual menu bar
   - Click reload button
   - Verify: New order is reflected in settings

3. **Section overrides are preserved**
   - Drag an icon from Shown to Hidden section in settings
   - Close and reopen settings
   - Verify: Icon still appears in Hidden section (user's choice)

4. **New apps appear in correct position**
   - Open Menu Bar Layout settings
   - Launch a new app with menu bar icon
   - Click reload button
   - Verify: New icon appears in its actual position

### Unit Tests

Add to `DrawerTests/UI/Settings/SettingsMenuBarLayoutViewTests.swift`:

```swift
// Test: Captured order is respected over saved order
func testReconcileLayout_UsesCapturedOrder() async {
    // Create captured icons with specific X positions
    let icon1 = MockCapturedIcon(x: 100, bundleId: "com.app1", section: .visible)
    let icon2 = MockCapturedIcon(x: 200, bundleId: "com.app2", section: .visible)
    let icon3 = MockCapturedIcon(x: 300, bundleId: "com.app3", section: .visible)

    // Create saved layout with DIFFERENT order
    let savedLayout = [
        SettingsLayoutItem(bundleIdentifier: "com.app3", section: .visible, order: 0),
        SettingsLayoutItem(bundleIdentifier: "com.app1", section: .visible, order: 1),
        SettingsLayoutItem(bundleIdentifier: "com.app2", section: .visible, order: 2),
    ]

    // Reconcile
    let result = reconcileLayout(
        capturedIcons: [icon1, icon2, icon3],
        savedLayout: savedLayout
    )

    // Verify: Order matches captured X positions, not saved order
    let visibleItems = result.items.filter { $0.section == .visible }.sorted { $0.order < $1.order }
    XCTAssertEqual(visibleItems[0].bundleIdentifier, "com.app1")
    XCTAssertEqual(visibleItems[1].bundleIdentifier, "com.app2")
    XCTAssertEqual(visibleItems[2].bundleIdentifier, "com.app3")
}

// Test: Section overrides are respected
func testReconcileLayout_RespectsSectionOverrides() async {
    // Create captured icon in visible section
    let icon = MockCapturedIcon(x: 100, bundleId: "com.app1", section: .visible)

    // Saved layout has it in hidden section (user override)
    let savedLayout = [
        SettingsLayoutItem(bundleIdentifier: "com.app1", section: .hidden, order: 0),
    ]

    // Reconcile
    let result = reconcileLayout(
        capturedIcons: [icon],
        savedLayout: savedLayout
    )

    // Verify: User's section override is respected
    XCTAssertEqual(result.items.first?.section, .hidden)
}
```

## Migration

No migration required. The saved layout will still be loaded, but its order values will be ignored in favor of captured order. Section overrides will continue to work.

## Dependencies

- `IconCapturer.swift` - Must correctly set `sectionType` on `CapturedIcon` based on separator positions
- `SettingsLayoutItem.swift` - `matches(capturedIcon:)` function must work correctly

## Risks

| Risk | Mitigation |
|------|------------|
| Users lose custom ordering | This is intentional - settings should reflect reality |
| Section overrides lost | Only order is changed; section overrides are preserved |
| Spacers affected | Spacers are preserved from saved layout unchanged |

## Debug Logging

Extensive debug logging is required for this feature to enable ongoing refinement and troubleshooting. All logs should use the `os.log` framework with appropriate log levels.

### Required Log Points

#### In `reconcileLayout()`

```swift
private let logger = Logger(
    subsystem: Bundle.main.bundleIdentifier ?? "com.drawer",
    category: "SettingsMenuBarLayoutView"
)

private func reconcileLayout(...) -> ReconciliationResult {
    logger.debug("=== RECONCILE LAYOUT START ===")
    logger.debug("Captured icons count: \(capturedIcons.count)")
    logger.debug("Saved layout count: \(savedLayout.count)")
    
    // Log each captured icon with position
    for (index, icon) in sortedIcons.enumerated() {
        let bundleId = icon.itemInfo?.ownerName ?? "unknown"
        let x = icon.originalFrame.minX
        let section = icon.sectionType
        logger.debug("  Captured[\(index)]: x=\(x), section=\(section), owner=\(bundleId)")
    }
    
    // Log section processing
    for sectionType in MenuBarSectionType.allCases {
        let sectionIcons = sortedIcons.filter { $0.sectionType == sectionType }
        logger.debug("Processing section \(sectionType.displayName): \(sectionIcons.count) icons")
        
        for (index, capturedIcon) in sectionIcons.enumerated() {
            // Log matching result
            if let savedItem = savedLayout.first(where: { $0.matches(capturedIcon: capturedIcon) }) {
                if savedItem.section != capturedIcon.sectionType {
                    logger.debug("  [\(index)] Section OVERRIDE: \(capturedIcon.sectionType) -> \(savedItem.section)")
                } else {
                    logger.debug("  [\(index)] Section match: \(capturedIcon.sectionType)")
                }
            } else {
                logger.debug("  [\(index)] NEW item (no saved match): \(capturedIcon.sectionType)")
            }
        }
    }
    
    logger.debug("=== RECONCILE LAYOUT END: \(reconciledItems.count) items ===")
    // ...
}
```

#### In `refreshItems()`

```swift
private func refreshItems() {
    logger.info("Refresh triggered")
    // ...
    
    logger.debug("Capture result: \(result.icons.count) icons")
    logger.debug("Reconciliation: matched=\(reconciled.matchedCount), new=\(reconciled.newCount)")
    
    // Log final layout state
    for sectionType in MenuBarSectionType.allCases {
        let items = reconciled.items.filter { $0.section == sectionType }
        logger.debug("Final \(sectionType.displayName): \(items.count) items")
    }
}
```

### Log Levels

| Level | Usage |
|-------|-------|
| `.debug` | Detailed flow information (counts, positions, matching details) |
| `.info` | Key events (refresh triggered, reconciliation complete) |
| `.warning` | Unexpected but recoverable situations |
| `.error` | Failures that prevent functionality |

### Viewing Logs

```bash
# Stream logs in Terminal
log stream --predicate 'subsystem == "com.drawer"' --level debug

# Filter to layout-specific logs
log stream --predicate 'subsystem == "com.drawer" AND category == "SettingsMenuBarLayoutView"' --level debug
```

## Definition of Done

- [ ] `reconcileLayout()` uses captured X-position order as source of truth
- [ ] Clicking reload button shows icons in actual menu bar order
- [ ] Section overrides from saved layout are still respected
- [ ] Spacers are preserved from saved layout
- [ ] **Extensive debug logging added per specification**
- [ ] Unit tests pass
- [ ] Manual test cases verified
