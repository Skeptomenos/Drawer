# Phase 5.4: Settings UI Integration

## Overview

Hook the `IconRepositioner` engine into the existing `SettingsMenuBarLayoutView` to trigger real menu bar repositioning when users drag icons.

## Files to Modify

### 1. `Drawer/UI/Settings/SettingsMenuBarLayoutView.swift`

Integrate repositioning into the drag-and-drop handlers.

## Implementation

### 1. Add Repositioning on Drop

When an icon is dropped in a new section or position, determine the target destination and call `IconRepositioner.move()`.

```swift
// Add to SettingsMenuBarLayoutView

// MARK: - Repositioning

extension SettingsMenuBarLayoutView {
    /// Handles repositioning when an icon is dropped.
    /// - Parameters:
    ///   - icon: The icon that was dropped.
    ///   - section: The section it was dropped into.
    ///   - index: The index within the section.
    private func handleDrop(
        icon: CapturedIcon,
        inSection section: MenuBarSection,
        atIndex index: Int
    ) {
        Task {
            await performReposition(icon: icon, section: section, index: index)
        }
    }
    
    @MainActor
    private func performReposition(
        icon: CapturedIcon,
        section: MenuBarSection,
        index: Int
    ) async {
        // Find the MenuBarItem for this icon
        guard let item = findMenuBarItem(for: icon) else {
            Logger.settings.error("Could not find MenuBarItem for \(icon.ownerName ?? "unknown")")
            return
        }
        
        // Determine the destination
        guard let destination = calculateDestination(
            for: item,
            inSection: section,
            atIndex: index
        ) else {
            Logger.settings.warning("Could not calculate destination for \(icon.ownerName ?? "unknown")")
            return
        }
        
        // Perform the move
        do {
            try await IconRepositioner.shared.move(item: item, to: destination)
            
            // Refresh the icon capture after successful move
            await refreshIconCapture()
        } catch {
            Logger.settings.error("Reposition failed: \(error.localizedDescription)")
            showRepositionError(error)
        }
    }
    
    /// Finds the MenuBarItem corresponding to a captured icon.
    private func findMenuBarItem(for icon: CapturedIcon) -> MenuBarItem? {
        let items = MenuBarItem.getMenuBarItems()
        
        // Match by bundle identifier and title, or by owner name
        return items.first { item in
            if let iconBundle = icon.bundleIdentifier,
               let itemBundle = item.bundleIdentifier {
                return iconBundle == itemBundle
            }
            return item.ownerName == icon.ownerName
        }
    }
    
    /// Calculates the move destination based on section and index.
    private func calculateDestination(
        for item: MenuBarItem,
        inSection section: MenuBarSection,
        atIndex index: Int
    ) -> MoveDestination? {
        let items = MenuBarItem.getMenuBarItems()
        
        // Get the control items for section boundaries
        let hiddenControlItem = items.first { $0.info == .hiddenControlItem }
        let alwaysHiddenControlItem = items.first { $0.info == .alwaysHiddenControlItem }
        
        switch section {
        case .visible:
            // Move to right of hidden control item (visible section starts here)
            if let controlItem = hiddenControlItem {
                return .rightOfItem(controlItem)
            }
            
        case .hidden:
            // Move to left of hidden control item
            if let controlItem = hiddenControlItem {
                return .leftOfItem(controlItem)
            }
            
        case .alwaysHidden:
            // Move to left of always-hidden control item
            if let controlItem = alwaysHiddenControlItem {
                return .leftOfItem(controlItem)
            }
        }
        
        // Fallback: find adjacent item at the target index
        return calculateAdjacentDestination(
            inSection: section,
            atIndex: index,
            allItems: items
        )
    }
    
    /// Calculates destination based on adjacent items.
    private func calculateAdjacentDestination(
        inSection section: MenuBarSection,
        atIndex index: Int,
        allItems: [MenuBarItem]
    ) -> MoveDestination? {
        // Get items in the target section
        let sectionItems = getSectionItems(section, from: allItems)
        
        guard !sectionItems.isEmpty else {
            return nil
        }
        
        // Clamp index to valid range
        let clampedIndex = min(index, sectionItems.count - 1)
        
        if clampedIndex < sectionItems.count {
            // Insert to the left of the item at this index
            return .leftOfItem(sectionItems[clampedIndex])
        } else if let lastItem = sectionItems.last {
            // Append to the right of the last item
            return .rightOfItem(lastItem)
        }
        
        return nil
    }
    
    /// Returns items belonging to a specific section.
    private func getSectionItems(
        _ section: MenuBarSection,
        from allItems: [MenuBarItem]
    ) -> [MenuBarItem] {
        // Find control item boundaries
        let hiddenControlIndex = allItems.firstIndex { $0.info == .hiddenControlItem }
        let alwaysHiddenControlIndex = allItems.firstIndex { $0.info == .alwaysHiddenControlItem }
        
        switch section {
        case .visible:
            // Items to the right of hidden control item
            if let idx = hiddenControlIndex {
                return Array(allItems[(idx + 1)...])
            }
            return []
            
        case .hidden:
            // Items between always-hidden and hidden control items
            let start = alwaysHiddenControlIndex.map { $0 + 1 } ?? 0
            let end = hiddenControlIndex ?? allItems.count
            if start < end {
                return Array(allItems[start..<end])
            }
            return []
            
        case .alwaysHidden:
            // Items to the left of always-hidden control item
            if let idx = alwaysHiddenControlIndex, idx > 0 {
                return Array(allItems[0..<idx])
            }
            return []
        }
    }
    
    /// Shows an error alert for failed repositioning.
    private func showRepositionError(_ error: Error) {
        let alert = NSAlert()
        alert.alertStyle = .warning
        alert.messageText = "Could Not Move Icon"
        alert.informativeText = error.localizedDescription
        alert.addButton(withTitle: "OK")
        alert.runModal()
    }
    
    /// Refreshes the icon capture after a successful move.
    private func refreshIconCapture() async {
        // Trigger a recapture of menu bar icons
        // This updates the Settings UI to reflect the new positions
        await appState?.iconCapturer.captureMenuBarIcons()
    }
}
```

### 2. Update Drop Handler in SwiftUI

Modify the existing `onDrop` or drag-drop modifiers to call `handleDrop()`:

```swift
// In the section view builder

ForEach(section.icons, id: \.id) { icon in
    IconView(icon: icon)
        .draggable(icon) // Already exists
}
.onDrop(of: [.capturedIcon], delegate: SectionDropDelegate(
    section: section,
    onDrop: { icon, index in
        handleDrop(icon: icon, inSection: section, atIndex: index)
    }
))
```

### 3. Add Lock Indicator for Immovable Icons

```swift
// In IconView

struct IconView: View {
    let icon: CapturedIcon
    
    var isImmovable: Bool {
        let info = MenuBarItemInfo(
            namespace: icon.bundleIdentifier ?? icon.ownerName ?? "",
            title: icon.title ?? ""
        )
        return info.isImmovable
    }
    
    var body: some View {
        ZStack(alignment: .topTrailing) {
            // Existing icon image
            iconImage
                .opacity(isImmovable ? 0.5 : 1.0)
            
            // Lock indicator for immovable items
            if isImmovable {
                Image(systemName: "lock.fill")
                    .font(.system(size: 8))
                    .foregroundColor(.secondary)
                    .padding(2)
            }
        }
        .help(isImmovable ? "This item cannot be moved by macOS" : icon.displayName)
    }
}
```

### 4. Disable Dragging for Immovable Icons

```swift
// Modify the draggable modifier

IconView(icon: icon)
    .if(!icon.isImmovable) { view in
        view.draggable(icon)
    }
```

Or use `onDrag` with a condition:

```swift
IconView(icon: icon)
    .onDrag {
        if icon.isImmovable {
            return NSItemProvider() // Empty provider, drag won't work
        }
        return NSItemProvider(object: icon)
    }
```

## Additional Files

### `Drawer/UI/Settings/SectionDropDelegate.swift`

Create a dedicated drop delegate for cleaner code:

```swift
//
//  SectionDropDelegate.swift
//  Drawer
//
//  Copyright Â© 2026 Drawer. MIT License.
//

import SwiftUI

/// Handles drop operations for menu bar layout sections.
struct SectionDropDelegate: DropDelegate {
    let section: MenuBarSection
    let icons: [CapturedIcon]
    let onDrop: (CapturedIcon, Int) -> Void
    let onMove: (IndexSet, Int) -> Void
    
    @Binding var draggedIcon: CapturedIcon?
    
    func dropEntered(info: DropInfo) {
        // Optional: highlight drop zone
    }
    
    func dropUpdated(info: DropInfo) -> DropProposal? {
        DropProposal(operation: .move)
    }
    
    func performDrop(info: DropInfo) -> Bool {
        guard let draggedIcon = draggedIcon else {
            return false
        }
        
        // Calculate drop index based on location
        let dropIndex = calculateDropIndex(at: info.location)
        
        // Trigger the reposition
        onDrop(draggedIcon, dropIndex)
        
        self.draggedIcon = nil
        return true
    }
    
    private func calculateDropIndex(at location: CGPoint) -> Int {
        // Find the index based on X position
        // Icons are laid out left-to-right
        for (index, icon) in icons.enumerated() {
            if location.x < icon.frame.midX {
                return index
            }
        }
        return icons.count
    }
}
```

## Acceptance Criteria

- [ ] Dragging icon between sections triggers real menu bar repositioning
- [ ] Dragging icon within section reorders icons in menu bar
- [ ] Immovable icons (Control Center, Clock, Siri) show lock indicator
- [ ] Immovable icons cannot be dragged
- [ ] Error alert shown when repositioning fails
- [ ] Settings UI refreshes to show new positions after successful move
- [ ] Typecheck passes: `xcodebuild -scheme Drawer build`
- [ ] Verify in app: drag icon between sections, observe real menu bar change

## Testing

### Manual Test Cases

1. **Move icon from Visible to Hidden**
   - Open Settings > Menu Bar Layout
   - Drag a visible third-party app icon to Hidden section
   - Verify: Icon moves in real menu bar (left of separator)
   - Verify: Settings UI updates to show icon in Hidden section

2. **Move icon from Hidden to Always Hidden**
   - Drag icon from Hidden to Always Hidden section
   - Verify: Icon disappears from visible menu bar entirely
   - Verify: Icon appears in Always Hidden section in Settings

3. **Move icon from Always Hidden to Visible**
   - Drag icon from Always Hidden to Visible section
   - Verify: Icon reappears in menu bar (right of separator)

4. **Reorder within Visible section**
   - Drag one visible icon to a different position within Visible
   - Verify: Icons reorder in real menu bar

5. **Attempt to drag Control Center**
   - Try to drag Control Center icon
   - Verify: Lock indicator visible
   - Verify: Drag gesture doesn't work or shows error

6. **Error handling**
   - (Simulate failure by killing target app mid-drag)
   - Verify: Error alert appears with retry suggestion

## Dependencies

- Phase 5.1: `MenuBarItem`, `MenuBarItemInfo` models
- Phase 5.3: `IconRepositioner` engine
- Existing `SettingsMenuBarLayoutView.swift`
- Existing icon capture infrastructure
