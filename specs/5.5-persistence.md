# Phase 5.5: Persistence

## Overview

Save user's preferred icon positions to UserDefaults and restore them on app launch.

## Files to Modify

### 1. `Drawer/Core/Managers/SettingsManager.swift`

Add icon position persistence.

## Implementation

### 1. Add Persistence Properties to SettingsManager

```swift
// Add to SettingsManager.swift

// MARK: - Icon Position Persistence

extension SettingsManager {
    /// Key for storing icon positions in UserDefaults.
    private static let iconPositionsKey = "menuBarIconPositions"
    
    /// Stored icon positions by section.
    /// Key: Section name ("visible", "hidden", "alwaysHidden")
    /// Value: Array of MenuBarItemInfo in order
    @Published var savedIconPositions: [String: [MenuBarItemInfo]] = [:] {
        didSet {
            saveIconPositions()
        }
    }
    
    /// Loads saved icon positions from UserDefaults.
    func loadIconPositions() {
        guard let data = UserDefaults.standard.data(forKey: Self.iconPositionsKey) else {
            Logger.settings.debug("No saved icon positions found")
            return
        }
        
        do {
            let positions = try JSONDecoder().decode(
                [String: [MenuBarItemInfo]].self,
                from: data
            )
            self.savedIconPositions = positions
            Logger.settings.info("Loaded \(positions.values.flatMap { $0 }.count) saved icon positions")
        } catch {
            Logger.settings.error("Failed to decode saved icon positions: \(error)")
        }
    }
    
    /// Saves current icon positions to UserDefaults.
    private func saveIconPositions() {
        do {
            let data = try JSONEncoder().encode(savedIconPositions)
            UserDefaults.standard.set(data, forKey: Self.iconPositionsKey)
            Logger.settings.debug("Saved icon positions")
        } catch {
            Logger.settings.error("Failed to encode icon positions: \(error)")
        }
    }
    
    /// Updates saved positions for a specific section.
    func updateSavedPositions(for section: MenuBarSection, icons: [MenuBarItemInfo]) {
        savedIconPositions[section.rawValue] = icons
    }
    
    /// Clears all saved icon positions.
    func clearSavedPositions() {
        savedIconPositions = [:]
        UserDefaults.standard.removeObject(forKey: Self.iconPositionsKey)
        Logger.settings.info("Cleared saved icon positions")
    }
}
```

### 2. Create IconPositionRestorer

```swift
//
//  IconPositionRestorer.swift
//  Drawer
//
//  Copyright Â© 2026 Drawer. MIT License.
//

import Foundation
import os.log

/// Restores saved icon positions on app launch.
@MainActor
final class IconPositionRestorer {
    
    // MARK: - Properties
    
    private let settingsManager: SettingsManager
    private let repositioner: IconRepositioner
    private let logger = Logger(
        subsystem: Bundle.main.bundleIdentifier ?? "Drawer",
        category: "IconPositionRestorer"
    )
    
    // MARK: - Initialization
    
    init(settingsManager: SettingsManager, repositioner: IconRepositioner = .shared) {
        self.settingsManager = settingsManager
        self.repositioner = repositioner
    }
    
    // MARK: - Public API
    
    /// Restores saved icon positions.
    /// Compares saved positions to current menu bar and moves icons as needed.
    func restorePositions() async {
        settingsManager.loadIconPositions()
        
        let savedPositions = settingsManager.savedIconPositions
        guard !savedPositions.isEmpty else {
            logger.debug("No saved positions to restore")
            return
        }
        
        logger.info("Starting position restoration")
        
        // Get current menu bar state
        let currentItems = MenuBarItem.getMenuBarItems()
        
        // Find control items for section boundaries
        guard let hiddenControlItem = currentItems.first(where: { $0.info == .hiddenControlItem }) else {
            logger.warning("Hidden control item not found, skipping restoration")
            return
        }
        
        let alwaysHiddenControlItem = currentItems.first { $0.info == .alwaysHiddenControlItem }
        
        // Restore each section
        await restoreSection(
            .alwaysHidden,
            savedItems: savedPositions["alwaysHidden"] ?? [],
            targetItem: alwaysHiddenControlItem,
            destination: { .leftOfItem($0) },
            currentItems: currentItems
        )
        
        await restoreSection(
            .hidden,
            savedItems: savedPositions["hidden"] ?? [],
            targetItem: hiddenControlItem,
            destination: { .leftOfItem($0) },
            currentItems: currentItems
        )
        
        await restoreSection(
            .visible,
            savedItems: savedPositions["visible"] ?? [],
            targetItem: hiddenControlItem,
            destination: { .rightOfItem($0) },
            currentItems: currentItems
        )
        
        logger.info("Position restoration complete")
    }
    
    // MARK: - Private Methods
    
    private func restoreSection(
        _ section: MenuBarSection,
        savedItems: [MenuBarItemInfo],
        targetItem: MenuBarItem?,
        destination: (MenuBarItem) -> MoveDestination,
        currentItems: [MenuBarItem]
    ) async {
        guard let targetItem = targetItem else {
            logger.debug("No target item for \(section.rawValue), skipping")
            return
        }
        
        for savedInfo in savedItems {
            // Find the current MenuBarItem matching this saved info
            guard let item = currentItems.first(where: { $0.info == savedInfo }) else {
                logger.debug("Saved item \(savedInfo.title) not found in current menu bar")
                continue
            }
            
            // Check if already in correct section
            if isItemInSection(item, section: section, currentItems: currentItems) {
                logger.debug("\(item.displayName) already in correct section")
                continue
            }
            
            // Move to correct section
            do {
                try await repositioner.move(item: item, to: destination(targetItem))
                logger.info("Restored \(item.displayName) to \(section.rawValue)")
            } catch {
                logger.warning("Failed to restore \(item.displayName): \(error.localizedDescription)")
            }
            
            // Brief pause between moves to avoid overwhelming the system
            try? await Task.sleep(for: .milliseconds(100))
        }
    }
    
    private func isItemInSection(
        _ item: MenuBarItem,
        section: MenuBarSection,
        currentItems: [MenuBarItem]
    ) -> Bool {
        guard let itemIndex = currentItems.firstIndex(of: item) else {
            return false
        }
        
        let hiddenControlIndex = currentItems.firstIndex { $0.info == .hiddenControlItem }
        let alwaysHiddenControlIndex = currentItems.firstIndex { $0.info == .alwaysHiddenControlItem }
        
        switch section {
        case .visible:
            // Items to the right of hidden control
            if let hiddenIdx = hiddenControlIndex {
                return itemIndex > hiddenIdx
            }
            return false
            
        case .hidden:
            // Items between always-hidden and hidden control
            let start = alwaysHiddenControlIndex.map { $0 + 1 } ?? 0
            let end = hiddenControlIndex ?? currentItems.count
            return itemIndex >= start && itemIndex < end
            
        case .alwaysHidden:
            // Items to the left of always-hidden control
            if let alwaysHiddenIdx = alwaysHiddenControlIndex {
                return itemIndex < alwaysHiddenIdx
            }
            return false
        }
    }
}
```

### 3. Hook Restoration into AppDelegate

```swift
// In AppDelegate.swift

// Add property
private var iconPositionRestorer: IconPositionRestorer?

// In applicationDidFinishLaunching or setupManagers
func setupIconPositionRestoration() {
    guard let settingsManager = appState?.settingsManager else { return }
    
    iconPositionRestorer = IconPositionRestorer(settingsManager: settingsManager)
    
    // Restore positions asynchronously (don't block app launch)
    Task {
        // Brief delay to let menu bar stabilize
        try? await Task.sleep(for: .seconds(2))
        await iconPositionRestorer?.restorePositions()
    }
}
```

### 4. Save Positions After Successful Move

In `SettingsMenuBarLayoutView`, after a successful repositioning:

```swift
// In performReposition() after successful move

// Update saved positions
let currentItems = MenuBarItem.getMenuBarItems()
let sectionItems = getSectionItems(section, from: currentItems)
let sectionInfos = sectionItems.map { $0.info }
appState?.settingsManager.updateSavedPositions(for: section, icons: sectionInfos)
```

### 5. Add Reset Option to Settings

```swift
// In SettingsGeneralView or SettingsMenuBarLayoutView

Button("Reset Icon Positions") {
    showResetConfirmation = true
}
.alert("Reset Icon Positions?", isPresented: $showResetConfirmation) {
    Button("Cancel", role: .cancel) { }
    Button("Reset", role: .destructive) {
        settingsManager.clearSavedPositions()
    }
} message: {
    Text("This will clear all saved icon position preferences. Icons will stay in their current positions but won't be restored on next launch.")
}
```

## MenuBarSection Enum

Ensure this enum exists and is Codable:

```swift
// In Drawer/Models/MenuBarSection.swift or similar

enum MenuBarSection: String, Codable, CaseIterable {
    case visible = "visible"
    case hidden = "hidden"
    case alwaysHidden = "alwaysHidden"
    
    var displayName: String {
        switch self {
        case .visible: return "Visible"
        case .hidden: return "Hidden"
        case .alwaysHidden: return "Always Hidden"
        }
    }
}
```

## Acceptance Criteria

- [ ] Icon positions saved to UserDefaults after each successful move
- [ ] `SettingsManager.loadIconPositions()` correctly decodes saved data
- [ ] `IconPositionRestorer.restorePositions()` moves icons to saved positions
- [ ] Restoration runs asynchronously, doesn't block app launch
- [ ] Missing icons (uninstalled apps) are skipped gracefully
- [ ] "Reset Icon Positions" button clears saved positions
- [ ] Logs show restoration progress
- [ ] Typecheck passes: `xcodebuild -scheme Drawer build`

## Testing

### Manual Test Cases

1. **Save positions on move**
   - Move an icon from Visible to Hidden
   - Check UserDefaults (use `defaults read com.drawer.Drawer`)
   - Verify: Icon position is saved

2. **Restore on launch**
   - Arrange icons in specific order
   - Quit and relaunch Drawer
   - Verify: Icons return to saved positions

3. **Handle missing icons**
   - Save positions with app X in Hidden
   - Quit app X
   - Relaunch Drawer
   - Verify: No crash, app X is skipped

4. **Reset positions**
   - Click "Reset Icon Positions"
   - Verify: Saved positions cleared
   - Relaunch Drawer
   - Verify: No restoration occurs

### Unit Tests

```swift
// In DrawerTests/Managers/SettingsManagerTests.swift

import XCTest
@testable import Drawer

final class IconPositionPersistenceTests: XCTestCase {
    var settingsManager: SettingsManager!
    
    override func setUp() {
        super.setUp()
        settingsManager = SettingsManager()
        // Clear any existing saved positions
        UserDefaults.standard.removeObject(forKey: "menuBarIconPositions")
    }
    
    override func tearDown() {
        UserDefaults.standard.removeObject(forKey: "menuBarIconPositions")
        super.tearDown()
    }
    
    func testSaveAndLoadPositions() {
        let testInfo = MenuBarItemInfo(namespace: "com.test.app", title: "Test")
        
        settingsManager.updateSavedPositions(for: .hidden, icons: [testInfo])
        
        // Create new instance to test loading
        let newManager = SettingsManager()
        newManager.loadIconPositions()
        
        XCTAssertEqual(newManager.savedIconPositions["hidden"]?.count, 1)
        XCTAssertEqual(newManager.savedIconPositions["hidden"]?.first, testInfo)
    }
    
    func testClearPositions() {
        let testInfo = MenuBarItemInfo(namespace: "com.test.app", title: "Test")
        settingsManager.updateSavedPositions(for: .hidden, icons: [testInfo])
        
        settingsManager.clearSavedPositions()
        
        XCTAssertTrue(settingsManager.savedIconPositions.isEmpty)
        XCTAssertNil(UserDefaults.standard.data(forKey: "menuBarIconPositions"))
    }
}
```

## Dependencies

- Phase 5.1: `MenuBarItem`, `MenuBarItemInfo` models
- Phase 5.3: `IconRepositioner` engine
- Phase 5.4: Settings UI integration (for saving after moves)
- Existing `SettingsManager.swift`
- Existing `AppDelegate.swift`
