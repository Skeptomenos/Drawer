# 5.7 Menu Bar Layout Repositioning Fix

## Overview

This specification addresses **Issue 2**: Dragging icons between sections in the Menu Bar Layout settings does not actually move them in the real menu bar.

## Problem Statement

When the user drags an icon from one section to another in the Menu Bar Layout settings (e.g., from "Shown Items" to "Hidden Items"), the icon appears to move in the UI but does not physically reposition in the actual menu bar.

### Root Cause

The `findIconItem()` function in `SettingsMenuBarLayoutView.swift` fails to find the matching `IconItem` needed for physical repositioning:

1. `SettingsLayoutItem` stores `bundleIdentifier` and `title` from the capture time
2. `findIconItem()` creates an `IconIdentifier` and searches for an exact match
3. The matching fails because:
   - `IconItem.identifier` uses `bundleIdentifier ?? ownerName ?? "unknown"` which may differ
   - Title matching is exact but titles can be empty or dynamic
   - The comparison fails when bundleIdentifier is nil on one side

### Expected Behavior

When dragging an icon between sections in the Menu Bar Layout settings, the icon should physically move in the actual menu bar to reflect the new section assignment.

## Technical Design

### Current Flow (Broken)

```
User drags icon to new section
    → moveItem() is called
    → performReposition() is called asynchronously
    → findIconItem() attempts to match by IconIdentifier
    → Returns nil (match fails)
    → No physical repositioning occurs
    → UI updates but real menu bar unchanged
```

### New Flow (Fixed)

```
User drags icon to new section
    → moveItem() is called
    → performReposition() is called asynchronously
    → findIconItem() uses cached windowID (fast path)
    → OR uses lenient matching with bundle ID + fallbacks
    → Returns valid IconItem
    → IconRepositioner.move() executes Command+Drag simulation
    → Real menu bar icon moves
    → Refresh captures new state
```

## Implementation

### File: `Drawer/UI/Settings/SettingsMenuBarLayoutView.swift`

#### Change 1: Add windowID cache

Add a new state property to cache windowIDs from captured icons:

```swift
// MARK: - State

/// Items for display, populated from IconCapturer and reconciled with saved layout
@State private var layoutItems: [SettingsLayoutItem] = []

/// Cache mapping layout item IDs to captured CGImages
@State private var imageCache: [UUID: CGImage] = [:]

/// Cache mapping layout item IDs to window IDs for reliable icon lookup
@State private var windowIDCache: [UUID: CGWindowID] = [:]

// ... rest of existing state
```

#### Change 2: Populate windowID cache in reconcileLayout()

Update the reconciliation to store windowIDs:

```swift
private func reconcileLayout(
    capturedIcons: [CapturedIcon],
    savedLayout: [SettingsLayoutItem]
) -> ReconciliationResult {
    var reconciledItems: [SettingsLayoutItem] = []
    var newImageCache: [UUID: CGImage] = [:]
    var newWindowIDCache: [UUID: CGWindowID] = [:]  // NEW
    var matchedCount = 0
    var newCount = 0

    // ... existing sorting and processing logic ...

    for (index, capturedIcon) in sectionIcons.enumerated() {
        // ... existing item creation logic ...

        if let item = SettingsLayoutItem.from(
            capturedIcon: capturedIcon,
            section: effectiveSection,
            order: index
        ) {
            reconciledItems.append(item)
            newImageCache[item.id] = capturedIcon.image
            
            // Cache the windowID for reliable lookup during repositioning
            if let windowID = capturedIcon.itemInfo?.windowID {
                newWindowIDCache[item.id] = windowID
            }
        }
    }

    // ... rest of existing logic ...

    return ReconciliationResult(
        items: reconciledItems,
        imageCache: newImageCache,
        windowIDCache: newWindowIDCache,  // NEW
        matchedCount: matchedCount,
        newCount: newCount
    )
}
```

#### Change 3: Update ReconciliationResult struct

```swift
/// Result of reconciling captured icons with saved layout.
private struct ReconciliationResult {
    /// Reconciled layout items
    let items: [SettingsLayoutItem]
    /// Cache mapping item IDs to captured images
    let imageCache: [UUID: CGImage]
    /// Cache mapping item IDs to window IDs for repositioning
    let windowIDCache: [UUID: CGWindowID]
    /// Number of items matched from saved layout
    let matchedCount: Int
    /// Number of new items not found in saved layout
    let newCount: Int
}
```

#### Change 4: Update refreshItems() to use new cache

```swift
private func refreshItems() {
    // ... existing code ...

    await MainActor.run {
        layoutItems = reconciled.items
        imageCache = reconciled.imageCache
        windowIDCache = reconciled.windowIDCache  // NEW
        isRefreshing = false
        hasUnsavedChanges = false
        // ...
    }
}
```

#### Change 5: Rewrite findIconItem() with robust matching

```swift
/// Finds the IconItem matching a SettingsLayoutItem.
///
/// Uses a multi-tier matching strategy:
/// 1. Fast path: Use cached windowID (most reliable)
/// 2. Fallback: Search by bundle ID with lenient title matching
///
/// - Parameter layoutItem: The layout item to find
/// - Returns: The matching IconItem, or nil if not found
private func findIconItem(for layoutItem: SettingsLayoutItem) -> IconItem? {
    // Fast path: Use cached windowID
    if let windowID = windowIDCache[layoutItem.id] {
        if let item = IconItem(windowID: windowID) {
            logger.debug("Found IconItem via windowID cache: \(item.displayName)")
            return item
        }
        // WindowID is stale (window closed/recreated), fall through to search
        logger.debug("Cached windowID \(windowID) is stale, searching by identifier")
    }

    // Fallback: Search all current menu bar items
    guard case .menuBarItem(let bundleId, let title) = layoutItem.itemType else {
        // Spacers don't have corresponding IconItems
        return nil
    }

    let allItems = IconItem.getMenuBarItems(onScreenOnly: false, activeSpaceOnly: true)

    // Strategy 1: Exact match (bundle ID + title)
    if let exactMatch = allItems.first(where: { item in
        item.bundleIdentifier == bundleId && item.title == title
    }) {
        logger.debug("Found IconItem via exact match: \(exactMatch.displayName)")
        return exactMatch
    }

    // Strategy 2: Bundle ID match with empty/nil title
    if title == nil || title?.isEmpty == true {
        if let bundleMatch = allItems.first(where: { item in
            item.bundleIdentifier == bundleId
        }) {
            logger.debug("Found IconItem via bundle ID match: \(bundleMatch.displayName)")
            return bundleMatch
        }
    }

    // Strategy 3: Bundle ID match ignoring title (for apps with dynamic titles)
    if let bundleMatch = allItems.first(where: { item in
        item.bundleIdentifier == bundleId
    }) {
        logger.debug("Found IconItem via bundle ID (ignoring title): \(bundleMatch.displayName)")
        return bundleMatch
    }

    // Strategy 4: Owner name match (fallback for apps without bundle ID)
    if let ownerMatch = allItems.first(where: { item in
        item.ownerName == bundleId  // bundleId might actually be ownerName
    }) {
        logger.debug("Found IconItem via owner name match: \(ownerMatch.displayName)")
        return ownerMatch
    }

    logger.warning("Could not find IconItem for \(layoutItem.displayName)")
    return nil
}
```

#### Change 6: Add error logging to performReposition()

```swift
@MainActor
private func performReposition(
    item: SettingsLayoutItem,
    to targetSection: MenuBarSectionType,
    at insertIndex: Int
) async {
    // Find the IconItem that matches this layout item
    guard let iconItem = findIconItem(for: item) else {
        logger.warning("Could not find IconItem for \(item.displayName) - physical repositioning skipped")
        logger.debug("  bundleId: \(item.bundleIdentifier ?? "nil")")
        logger.debug("  title: \(item.title ?? "nil")")
        logger.debug("  windowID cache: \(windowIDCache[item.id].map(String.init) ?? "nil")")
        return
    }

    // ... rest of existing implementation ...
}
```

### Key Behavioral Changes

| Behavior | Before | After |
|----------|--------|-------|
| Icon lookup method | Identifier equality only | WindowID cache + multi-tier fallback |
| Match reliability | Fails often | Succeeds in most cases |
| Physical repositioning | Skipped when match fails | Executes with valid IconItem |
| Debug visibility | Silent failure | Logged with details |

## Alternative Approach: Live MenuBarItem References

An alternative implementation would follow Ice's approach more closely by keeping live `MenuBarItem` objects instead of identifiers:

```swift
// Store actual MenuBarItem objects alongside layout items
@State private var menuBarItemsCache: [UUID: MenuBarItem] = [:]

// In reconcileLayout(), store the MenuBarItem directly
if let windowID = capturedIcon.itemInfo?.windowID,
   let menuBarItem = MenuBarItem(windowID: windowID) {
    menuBarItemsCache[item.id] = menuBarItem
}

// In findIconItem(), return the cached MenuBarItem's IconItem equivalent
if let menuBarItem = menuBarItemsCache[layoutItem.id] {
    return IconItem(windowID: menuBarItem.windowID)
}
```

This approach is simpler but requires importing or creating `MenuBarItem` objects, which adds a dependency on the WindowInfo utilities.

## Testing

### Manual Test Cases

1. **Drag to Hidden section**
   - Open Menu Bar Layout settings
   - Drag an icon from "Shown Items" to "Hidden Items"
   - Collapse the menu bar (click toggle)
   - Verify: The icon is now in the hidden section of the real menu bar

2. **Drag to Visible section**
   - Expand the menu bar to see hidden icons
   - Open Menu Bar Layout settings
   - Drag an icon from "Hidden Items" to "Shown Items"
   - Collapse the menu bar
   - Verify: The icon remains visible after collapse

3. **Drag to Always Hidden section**
   - Open Menu Bar Layout settings
   - Drag an icon from "Shown Items" to "Always Hidden Items"
   - Verify: The icon is no longer visible even when expanded

4. **Reorder within section**
   - Open Menu Bar Layout settings
   - Drag an icon to a different position within the same section
   - Verify: The icon physically moves in the menu bar

5. **Immovable items**
   - Open Menu Bar Layout settings
   - Attempt to drag Control Center or Clock
   - Verify: Items cannot be dragged (lock icon shown)

### Unit Tests

Add to `DrawerTests/UI/Settings/SettingsMenuBarLayoutViewTests.swift`:

```swift
// Test: findIconItem uses windowID cache
func testFindIconItem_UsesWindowIDCache() {
    let layoutItem = SettingsLayoutItem(bundleIdentifier: "com.test", section: .visible)
    let windowID: CGWindowID = 12345
    
    // Populate cache
    windowIDCache[layoutItem.id] = windowID
    
    // Mock IconItem creation from windowID
    let result = findIconItem(for: layoutItem)
    
    // Verify windowID was used (requires mock)
    XCTAssertNotNil(result)
}

// Test: findIconItem falls back to bundle ID matching
func testFindIconItem_FallsBackToBundleID() {
    let layoutItem = SettingsLayoutItem(
        bundleIdentifier: "com.apple.finder",
        title: "DynamicTitle",
        section: .visible
    )
    
    // No windowID cached
    windowIDCache[layoutItem.id] = nil
    
    // Mock menu bar items with different title but same bundle ID
    let mockItems = [
        MockIconItem(bundleIdentifier: "com.apple.finder", title: "DifferentTitle")
    ]
    
    let result = findIconItem(for: layoutItem)
    
    // Should find by bundle ID despite title mismatch
    XCTAssertNotNil(result)
    XCTAssertEqual(result?.bundleIdentifier, "com.apple.finder")
}

// Test: Spacers return nil
func testFindIconItem_ReturnsNilForSpacers() {
    let spacer = SettingsLayoutItem.spacer(section: .hidden, order: 0)
    
    let result = findIconItem(for: spacer)
    
    XCTAssertNil(result)
}
```

### Integration Tests

```swift
// Test: Full drag-drop flow triggers repositioning
func testDragDrop_TriggersReposition() async {
    // Setup: Create view with known icons
    let view = SettingsMenuBarLayoutView()
    await view.refreshItems()
    
    // Get an item from visible section
    let visibleItems = view.items(for: .visible)
    guard let item = visibleItems.first else {
        XCTFail("No visible items")
        return
    }
    
    // Simulate drag to hidden section
    view.moveItem(item, to: .hidden, at: 0)
    
    // Wait for async repositioning
    try await Task.sleep(for: .milliseconds(500))
    
    // Verify: Item is now in hidden section of real menu bar
    let currentItems = IconItem.getMenuBarItems()
    // ... verification logic ...
}
```

## Dependencies

- `IconItem.swift` - Must support initialization from `windowID`
- `IconRepositioner.swift` - Must be functional for Command+Drag simulation
- `Bridging.swift` - Must provide `getWindowFrame(for:)` for position verification

## Error Handling

When repositioning fails, the following should occur:

1. **Log the error** with details about which item failed and why
2. **Show user-facing alert** via `showRepositionError()`
3. **Refresh the view** to show actual menu bar state (not the attempted state)
4. **DO NOT persist** the failed section change to saved layout

## Risks

| Risk | Mitigation |
|------|------------|
| WindowID becomes stale | Multi-tier fallback to identifier matching |
| Bundle ID not available | Fallback to ownerName matching |
| IconRepositioner fails | Retry logic + user alert + view refresh |
| Performance impact | WindowID cache avoids repeated searches |

## Debug Logging

Extensive debug logging is critical for this feature due to the complexity of icon matching and CGEvent-based repositioning. All logs should be preserved for ongoing refinement.

### Required Log Points

#### In `findIconItem()`

```swift
private func findIconItem(for layoutItem: SettingsLayoutItem) -> IconItem? {
    logger.debug("=== FIND ICON ITEM START ===")
    logger.debug("Looking for: bundleId=\(layoutItem.bundleIdentifier ?? "nil"), title=\(layoutItem.title ?? "nil")")
    logger.debug("Layout item ID: \(layoutItem.id)")
    
    // Fast path: windowID cache
    if let windowID = windowIDCache[layoutItem.id] {
        logger.debug("WindowID cache HIT: \(windowID)")
        if let item = IconItem(windowID: windowID) {
            logger.debug("  -> Found valid IconItem: \(item.displayName)")
            return item
        } else {
            logger.debug("  -> WindowID \(windowID) is STALE (window no longer exists)")
        }
    } else {
        logger.debug("WindowID cache MISS")
    }
    
    // Search all items
    let allItems = IconItem.getMenuBarItems(onScreenOnly: false, activeSpaceOnly: true)
    logger.debug("Searching \(allItems.count) menu bar items...")
    
    // Log all available items for debugging
    for (index, item) in allItems.enumerated() {
        logger.debug("  Available[\(index)]: bundle=\(item.bundleIdentifier ?? "nil"), title=\(item.title ?? "nil"), windowID=\(item.windowID)")
    }
    
    // Try each matching strategy
    if let exactMatch = allItems.first(where: { $0.bundleIdentifier == bundleId && $0.title == title }) {
        logger.debug("Match via EXACT (bundle + title): \(exactMatch.displayName)")
        return exactMatch
    }
    
    if let bundleMatch = allItems.first(where: { $0.bundleIdentifier == bundleId }) {
        logger.debug("Match via BUNDLE ID only: \(bundleMatch.displayName)")
        return bundleMatch
    }
    
    if let ownerMatch = allItems.first(where: { $0.ownerName == bundleId }) {
        logger.debug("Match via OWNER NAME: \(ownerMatch.displayName)")
        return ownerMatch
    }
    
    logger.warning("=== FIND ICON ITEM FAILED: No match for \(layoutItem.displayName) ===")
    return nil
}
```

#### In `performReposition()`

```swift
@MainActor
private func performReposition(
    item: SettingsLayoutItem,
    to targetSection: MenuBarSectionType,
    at insertIndex: Int
) async {
    logger.info("=== REPOSITION START ===")
    logger.info("Item: \(item.displayName)")
    logger.info("Target section: \(targetSection.displayName), insert index: \(insertIndex)")
    
    guard let iconItem = findIconItem(for: item) else {
        logger.error("REPOSITION ABORTED: Could not find IconItem")
        logger.error("  bundleId: \(item.bundleIdentifier ?? "nil")")
        logger.error("  title: \(item.title ?? "nil")")
        logger.error("  windowIDCache has entry: \(windowIDCache[item.id] != nil)")
        return
    }
    
    logger.debug("Found IconItem: windowID=\(iconItem.windowID), frame=\(iconItem.frame)")
    
    guard let destination = calculateDestination(for: targetSection, at: insertIndex, excludingItem: iconItem) else {
        logger.error("REPOSITION ABORTED: Could not calculate destination")
        return
    }
    
    logger.debug("Calculated destination: \(String(describing: destination))")
    
    do {
        logger.info("Calling IconRepositioner.move()...")
        try await IconRepositioner.shared.move(item: iconItem, to: destination)
        logger.info("=== REPOSITION SUCCESS ===")
    } catch let error as RepositionError {
        logger.error("=== REPOSITION FAILED: \(error.localizedDescription) ===")
    } catch {
        logger.error("=== REPOSITION FAILED (unexpected): \(error.localizedDescription) ===")
    }
}
```

#### In `calculateDestination()`

```swift
private func calculateDestination(
    for targetSection: MenuBarSectionType,
    at insertIndex: Int,
    excludingItem: IconItem
) -> MoveDestination? {
    logger.debug("Calculating destination for section \(targetSection.displayName) at index \(insertIndex)")
    
    let allItems = IconItem.getMenuBarItems(onScreenOnly: false, activeSpaceOnly: true)
    logger.debug("Total menu bar items: \(allItems.count)")
    
    let hiddenControlItem = allItems.first { $0.identifier == .hiddenControlItem }
    let alwaysHiddenControlItem = allItems.first { $0.identifier == .alwaysHiddenControlItem }
    
    logger.debug("Control items: hidden=\(hiddenControlItem?.frame.minX ?? -1), alwaysHidden=\(alwaysHiddenControlItem?.frame.minX ?? -1)")
    
    let sectionItems = getSectionItems(for: targetSection, from: allItems, ...)
    logger.debug("Section \(targetSection.displayName) has \(sectionItems.count) items")
    
    // Log the calculated destination
    // ... destination calculation ...
    
    if let dest = destination {
        logger.debug("Destination calculated: \(String(describing: dest))")
    } else {
        logger.warning("Could not calculate destination for \(targetSection.displayName) at \(insertIndex)")
    }
    
    return destination
}
```

#### In `moveItem()`

```swift
private func moveItem(_ item: SettingsLayoutItem, to targetSection: MenuBarSectionType, at insertIndex: Int) {
    logger.info("=== MOVE ITEM (UI) ===")
    logger.info("Moving \(item.displayName) to \(targetSection.displayName) at \(insertIndex)")
    logger.debug("Item is spacer: \(item.isSpacer), is immovable: \(item.isImmovable)")
    
    let shouldReposition = !item.isSpacer && !item.isImmovable
    logger.debug("Should trigger physical reposition: \(shouldReposition)")
    
    // ... rest of implementation ...
    
    logger.debug("UI state updated, saving layout...")
}
```

### Log Levels

| Level | Usage |
|-------|-------|
| `.debug` | Detailed matching, calculation, and state information |
| `.info` | Key events (reposition start/success, item moves) |
| `.warning` | Recoverable issues (stale cache, fallback matching used) |
| `.error` | Failures (no match found, reposition failed) |

### Viewing Logs

```bash
# Stream all Drawer logs
log stream --predicate 'subsystem == "com.drawer"' --level debug

# Filter to layout and repositioning
log stream --predicate 'subsystem == "com.drawer" AND (category == "SettingsMenuBarLayoutView" OR category == "IconRepositioner")' --level debug

# Save logs to file for analysis
log stream --predicate 'subsystem == "com.drawer"' --level debug > drawer_debug.log
```

### Persistent Logging Note

**IMPORTANT**: Debug logging for this feature should NOT be removed after implementation. The complexity of menu bar icon management requires ongoing visibility for:
- User bug reports
- Future refinements
- Compatibility testing with new macOS versions
- Debugging third-party app interactions

See AGENTS.md section 11 for logging guidelines.

## Definition of Done

- [ ] `windowIDCache` added and populated during reconciliation
- [ ] `ReconciliationResult` includes windowIDCache
- [ ] `findIconItem()` uses windowID cache as fast path
- [ ] `findIconItem()` has multi-tier fallback matching
- [ ] **Extensive debug logging added per specification**
- [ ] **All log points preserved (not removed after debugging)**
- [ ] Dragging icons between sections physically moves them in menu bar
- [ ] Unit tests pass
- [ ] Manual test cases verified
- [ ] Immovable items (Control Center, Clock) show lock and cannot be dragged
