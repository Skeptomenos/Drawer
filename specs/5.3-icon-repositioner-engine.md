# Phase 5.3: IconRepositioner Engine

## Overview

Create the core engine that moves menu bar icons using CGEvent simulation. This is the most complex phase and follows Ice's proven approach.

## Files to Create

### 1. `Drawer/Utilities/MouseCursor.swift`

Helper for cursor management during repositioning.

```swift
//
//  MouseCursor.swift
//  Drawer
//
//  Copyright © 2026 Drawer. MIT License.
//

import AppKit
import CoreGraphics

/// Utilities for managing the mouse cursor during repositioning operations.
enum MouseCursor {
    /// Returns the current cursor location in CoreGraphics screen coordinates.
    static var location: CGPoint? {
        CGEvent(source: nil)?.location
    }
    
    /// Hides the mouse cursor.
    static func hide() {
        CGDisplayHideCursor(CGMainDisplayID())
    }
    
    /// Shows the mouse cursor.
    static func show() {
        CGDisplayShowCursor(CGMainDisplayID())
    }
    
    /// Warps (teleports) the cursor to the specified location.
    ///
    /// - Parameter point: The target location in screen coordinates.
    static func warp(to point: CGPoint) {
        CGWarpMouseCursorPosition(point)
    }
}
```

### 2. `Drawer/Core/Engines/IconRepositioner.swift`

The core repositioning engine.

```swift
//
//  IconRepositioner.swift
//  Drawer
//
//  Copyright © 2026 Drawer. MIT License.
//

import AppKit
import CoreGraphics
import os.log

// MARK: - RepositionError

/// Errors that can occur during menu bar item repositioning.
enum RepositionError: Error, LocalizedError {
    /// The item cannot be moved (system item).
    case notMovable(MenuBarItem)
    
    /// The item is invalid or no longer exists.
    case invalidItem(MenuBarItem)
    
    /// Failed to create a CGEvent.
    case eventCreationFailed
    
    /// The operation timed out waiting for frame change.
    case timeout(MenuBarItem)
    
    /// Failed to get cursor location.
    case invalidCursorLocation
    
    /// Failed to create event source.
    case invalidEventSource
    
    /// Generic failure after all retries.
    case couldNotComplete(MenuBarItem)
    
    var errorDescription: String? {
        switch self {
        case .notMovable(let item):
            return "\"\(item.displayName)\" cannot be moved by macOS"
        case .invalidItem(let item):
            return "\"\(item.displayName)\" is no longer valid"
        case .eventCreationFailed:
            return "Failed to create repositioning event"
        case .timeout(let item):
            return "Timed out moving \"\(item.displayName)\""
        case .invalidCursorLocation:
            return "Could not determine cursor location"
        case .invalidEventSource:
            return "Could not create event source"
        case .couldNotComplete(let item):
            return "Could not move \"\(item.displayName)\""
        }
    }
}

// MARK: - MoveDestination

/// A destination for moving a menu bar item.
enum MoveDestination {
    /// Move to the left of the specified item.
    case leftOfItem(MenuBarItem)
    
    /// Move to the right of the specified item.
    case rightOfItem(MenuBarItem)
    
    /// The target item for this destination.
    var targetItem: MenuBarItem {
        switch self {
        case .leftOfItem(let item), .rightOfItem(let item):
            return item
        }
    }
}

// MARK: - IconRepositioner

/// Engine for repositioning menu bar icons via CGEvent simulation.
@MainActor
final class IconRepositioner {
    
    // MARK: - Properties
    
    private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "Drawer", category: "IconRepositioner")
    
    /// Number of retry attempts for failed moves.
    private let maxRetries = 5
    
    /// Timeout for waiting for frame change.
    private let frameChangeTimeout: Duration = .milliseconds(50)
    
    /// Polling interval for frame change detection.
    private let frameChangePollInterval: Duration = .milliseconds(10)
    
    // MARK: - Singleton
    
    static let shared = IconRepositioner()
    
    private init() {}
    
    // MARK: - Public API
    
    /// Moves a menu bar item to the specified destination.
    ///
    /// - Parameters:
    ///   - item: The item to move.
    ///   - destination: Where to move the item.
    /// - Throws: `RepositionError` if the move fails.
    func move(item: MenuBarItem, to destination: MoveDestination) async throws {
        guard item.isMovable else {
            throw RepositionError.notMovable(item)
        }
        
        // Check if already in correct position
        if try itemHasCorrectPosition(item: item, for: destination) {
            logger.debug("\(item.displayName) is already in correct position")
            return
        }
        
        logger.info("Moving \(item.displayName) to \(String(describing: destination))")
        
        // Save cursor location to restore later
        guard let cursorLocation = MouseCursor.location else {
            throw RepositionError.invalidCursorLocation
        }
        
        // Get initial frame to verify movement
        guard let initialFrame = Bridging.getWindowFrame(for: item.windowID) else {
            throw RepositionError.invalidItem(item)
        }
        
        // Hide cursor during operation
        MouseCursor.hide()
        defer {
            MouseCursor.warp(to: cursorLocation)
            MouseCursor.show()
        }
        
        // Retry loop
        for attempt in 1...maxRetries {
            do {
                try await performMove(item: item, to: destination)
                
                // Verify the move succeeded
                guard let newFrame = Bridging.getWindowFrame(for: item.windowID) else {
                    throw RepositionError.invalidItem(item)
                }
                
                if newFrame != initialFrame {
                    logger.info("Successfully moved \(item.displayName)")
                    return
                } else {
                    throw RepositionError.couldNotComplete(item)
                }
            } catch {
                if attempt < maxRetries {
                    logger.warning("Attempt \(attempt) failed for \(item.displayName): \(error.localizedDescription)")
                    try await wakeUpItem(item)
                    logger.info("Retrying move of \(item.displayName)")
                } else {
                    throw error
                }
            }
        }
    }
    
    // MARK: - Private Implementation
    
    /// Performs a single move attempt.
    private func performMove(item: MenuBarItem, to destination: MoveDestination) async throws {
        guard let source = CGEventSource(stateID: .hidSystemState) else {
            throw RepositionError.invalidEventSource
        }
        
        // Calculate points
        let startPoint = CGPoint(x: 20_000, y: 20_000) // Off-screen start
        let endPoint = try getEndPoint(for: destination)
        
        // Create mouse down event with Command modifier
        guard let mouseDownEvent = createMoveEvent(
            type: .leftMouseDown,
            location: startPoint,
            item: item,
            source: source,
            isDown: true
        ) else {
            throw RepositionError.eventCreationFailed
        }
        
        // Create mouse up event at destination
        guard let mouseUpEvent = createMoveEvent(
            type: .leftMouseUp,
            location: endPoint,
            item: destination.targetItem,
            source: source,
            isDown: false
        ) else {
            throw RepositionError.eventCreationFailed
        }
        
        // Get initial frame for change detection
        guard let initialFrame = Bridging.getWindowFrame(for: item.windowID) else {
            throw RepositionError.invalidItem(item)
        }
        
        // Permit all events during suppression
        try permitAllEvents(for: source)
        
        // Post mouse down and wait for frame change
        postEvent(mouseDownEvent, to: item.ownerPID)
        try await waitForFrameChange(of: item, initialFrame: initialFrame)
        
        // Get new frame for second wait
        guard let midFrame = Bridging.getWindowFrame(for: item.windowID) else {
            throw RepositionError.invalidItem(item)
        }
        
        // Post mouse up and wait for frame change
        postEvent(mouseUpEvent, to: item.ownerPID)
        try await waitForFrameChange(of: item, initialFrame: midFrame)
    }
    
    /// Creates a CGEvent for menu bar item movement.
    private func createMoveEvent(
        type: CGEventType,
        location: CGPoint,
        item: MenuBarItem,
        source: CGEventSource,
        isDown: Bool
    ) -> CGEvent? {
        guard let event = CGEvent(
            mouseEventSource: source,
            mouseType: type,
            mouseCursorPosition: location,
            mouseButton: .left
        ) else {
            return nil
        }
        
        // Add Command modifier for drag (only on mouse down)
        if isDown {
            event.flags = .maskCommand
        }
        
        // Set window targeting fields
        let windowID = Int64(item.windowID)
        let targetPID = Int64(item.ownerPID)
        
        event.setIntegerValueField(.eventTargetUnixProcessID, value: targetPID)
        event.setIntegerValueField(.mouseEventWindowUnderMousePointer, value: windowID)
        event.setIntegerValueField(.mouseEventWindowUnderMousePointerThatCanHandleThisEvent, value: windowID)
        
        // Window ID field (0x33)
        if let windowIDField = CGEventField(rawValue: 0x33) {
            event.setIntegerValueField(windowIDField, value: windowID)
        }
        
        // Set unique user data for event matching
        let userData = Int64(truncatingIfNeeded: Int(bitPattern: ObjectIdentifier(event)))
        event.setIntegerValueField(.eventSourceUserData, value: userData)
        
        return event
    }
    
    /// Posts an event to the specified process and session.
    private func postEvent(_ event: CGEvent, to pid: pid_t) {
        // Post to the app's PID
        event.postToPid(pid)
        
        // Also post to session for system-wide effect
        event.post(tap: .cgSessionEventTap)
    }
    
    /// Permits all local events during suppression states.
    private func permitAllEvents(for source: CGEventSource) throws {
        let filter: CGEventFilterMask = [
            .permitLocalMouseEvents,
            .permitLocalKeyboardEvents,
            .permitSystemDefinedEvents
        ]
        
        source.setLocalEventsFilterDuringSuppressionState(
            filter,
            state: .eventSuppressionStateRemoteMouseDrag
        )
        source.setLocalEventsFilterDuringSuppressionState(
            filter,
            state: .eventSuppressionStateSuppressionInterval
        )
        source.localEventsSuppressionInterval = 0
    }
    
    /// Returns the end point for a move destination.
    private func getEndPoint(for destination: MoveDestination) throws -> CGPoint {
        let targetItem = destination.targetItem
        guard let frame = Bridging.getWindowFrame(for: targetItem.windowID) else {
            throw RepositionError.invalidItem(targetItem)
        }
        
        switch destination {
        case .leftOfItem:
            return CGPoint(x: frame.minX, y: frame.midY)
        case .rightOfItem:
            return CGPoint(x: frame.maxX, y: frame.midY)
        }
    }
    
    /// Checks if an item is already in the correct position.
    private func itemHasCorrectPosition(item: MenuBarItem, for destination: MoveDestination) throws -> Bool {
        guard let itemFrame = Bridging.getWindowFrame(for: item.windowID) else {
            throw RepositionError.invalidItem(item)
        }
        
        guard let targetFrame = Bridging.getWindowFrame(for: destination.targetItem.windowID) else {
            throw RepositionError.invalidItem(destination.targetItem)
        }
        
        switch destination {
        case .leftOfItem:
            return itemFrame.maxX == targetFrame.minX
        case .rightOfItem:
            return itemFrame.minX == targetFrame.maxX
        }
    }
    
    /// Waits for an item's frame to change from the initial frame.
    private func waitForFrameChange(
        of item: MenuBarItem,
        initialFrame: CGRect
    ) async throws {
        let deadline = ContinuousClock.now + frameChangeTimeout
        
        while ContinuousClock.now < deadline {
            guard let currentFrame = Bridging.getWindowFrame(for: item.windowID) else {
                throw RepositionError.invalidItem(item)
            }
            
            if currentFrame != initialFrame {
                logger.debug("Frame changed for \(item.displayName)")
                return
            }
            
            try await Task.sleep(for: frameChangePollInterval)
        }
        
        throw RepositionError.timeout(item)
    }
    
    /// Attempts to wake up an unresponsive item with a click.
    private func wakeUpItem(_ item: MenuBarItem) async throws {
        logger.debug("Attempting to wake up \(item.displayName)")
        
        guard let source = CGEventSource(stateID: .hidSystemState) else {
            throw RepositionError.invalidEventSource
        }
        
        guard let frame = Bridging.getWindowFrame(for: item.windowID) else {
            throw RepositionError.invalidItem(item)
        }
        
        let clickPoint = CGPoint(x: frame.midX, y: frame.midY)
        
        // Create click events (no Command modifier)
        guard let mouseDownEvent = CGEvent(
            mouseEventSource: source,
            mouseType: .leftMouseDown,
            mouseCursorPosition: clickPoint,
            mouseButton: .left
        ),
        let mouseUpEvent = CGEvent(
            mouseEventSource: source,
            mouseType: .leftMouseUp,
            mouseCursorPosition: clickPoint,
            mouseButton: .left
        ) else {
            throw RepositionError.eventCreationFailed
        }
        
        // Set window targeting
        let windowID = Int64(item.windowID)
        mouseDownEvent.setIntegerValueField(.mouseEventWindowUnderMousePointer, value: windowID)
        mouseUpEvent.setIntegerValueField(.mouseEventWindowUnderMousePointer, value: windowID)
        
        // Post click events
        postEvent(mouseDownEvent, to: item.ownerPID)
        try await Task.sleep(for: .milliseconds(10))
        postEvent(mouseUpEvent, to: item.ownerPID)
        
        // Brief pause to let the app respond
        try await Task.sleep(for: .milliseconds(50))
    }
}
```

## CGEventField Extension

Add to the IconRepositioner file or a separate extensions file:

```swift
// MARK: - CGEventField Extension

private extension CGEventField {
    /// Field for the window ID (undocumented but stable).
    static let windowID = CGEventField(rawValue: 0x33)!
}
```

## Acceptance Criteria

- [ ] `IconRepositioner.move(item:to:)` successfully moves icons between sections
- [ ] Mouse cursor is hidden during operation and restored after
- [ ] Retries up to 5 times on failure with wake-up clicks
- [ ] Frame change is verified before returning success
- [ ] Throws `RepositionError.notMovable` for system icons
- [ ] Throws `RepositionError.timeout` if frame doesn't change
- [ ] Logs all operations via `os.log`
- [ ] Typecheck passes: `xcodebuild -scheme Drawer build`

## Testing

Due to the nature of CGEvent operations, most testing must be manual:

### Manual Test Cases

1. **Move icon from Shown to Hidden**
   - Open Settings > Menu Bar Layout
   - Drag a third-party app icon from Shown to Hidden section
   - Verify: Icon moves in real menu bar (left of separator)

2. **Move icon from Hidden to Always Hidden**
   - Drag icon from Hidden to Always Hidden section
   - Verify: Icon disappears from visible menu bar

3. **Attempt to move Control Center**
   - Try to drag Control Center icon
   - Verify: Error or lock indicator appears

4. **Retry on failure**
   - (Requires simulating a slow-responding app)
   - Verify: Logs show retry attempts

### Unit Tests (Limited)

```swift
// In DrawerTests/Engines/IconRepositionerTests.swift

import XCTest
@testable import Drawer

final class IconRepositionerTests: XCTestCase {
    func testNotMovableError() async {
        let immovableInfo = MenuBarItemInfo(namespace: "com.apple.controlcenter", title: "BentoBox")
        
        // Find the Control Center item
        let items = MenuBarItem.getMenuBarItems()
        guard let controlCenter = items.first(where: { $0.info == immovableInfo }) else {
            XCTSkip("Control Center not found in menu bar")
            return
        }
        
        // Attempting to move should throw notMovable
        do {
            try await IconRepositioner.shared.move(
                item: controlCenter,
                to: .leftOfItem(items.first!)
            )
            XCTFail("Should have thrown notMovable error")
        } catch let error as RepositionError {
            if case .notMovable = error {
                // Expected
            } else {
                XCTFail("Expected notMovable, got \(error)")
            }
        } catch {
            XCTFail("Unexpected error: \(error)")
        }
    }
}
```

## Dependencies

- Phase 5.1: `MenuBarItem`, `MenuBarItemInfo` models
- Phase 5.2: `Bridging.getWindowFrame(for:)`, `Bridging.getWindowList(option:)`
